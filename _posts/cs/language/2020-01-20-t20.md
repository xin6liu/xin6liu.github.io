---
layout: post
title: 递归
date: 2020-01-20
category: cs
tags: algorithm language
---

# 递归

* 第一要素：明确你这个函数想要干什么
```c
// 算 n 的阶乘(假设n不为0)
int f(int n){}
```

* 第二要素：寻找递归结束条件
```c
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
}
```

* 第三要素：找出函数的等价关系式

我们要**不断缩小参数的范围**，缩小之后，我们可以通过一些辅助的变量或者操作，**使原函数的结果不变**。

例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即 f(n) = n * f(n-1)。

```c
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
    // 把 f(n) 的等价操作写进去
    return f(n-1) * n;
}
```


## 案例1：斐波那契数列

if(n <= 2){return 1;}
f(n) = f(n-1) + f(n-2)

## 案例2：小青蛙跳台阶
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。

if(n == 1){return 1;}

第三要素：找出函数的等价关系式

每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。

第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。

第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。

所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：

```c
int f(int n){
    if(n == 1){
        return 1;
    }
    ruturn f(n-1) + f(n-2);
}
```
大家觉得上面的代码对不对？

答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。

这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：

```c
int f(int n){
    //f(0) = 0,f(1) = 1，等价于 n<=1时，f(n) = n。
    if(n <= 1){
        return n;
    }
    ruturn f(n-1) + f(n-2);
}
```


## 案例3：反转单链表

**reverseList(head)** 等价于： **reverseList(head.next)** + **改变一下1，2两个节点的指向**
```java
 public static Node reverseList(Node head){
        if(head == null || head.next == null){
            return head;
        }
        Node temp = reverseList(head.next); // 4->3->2
        head.next.next = head; // 2->1
        head.next = null;   // 1->null
        return temp;
    }
```

## 有关递归的一些优化思路
例如对于案例2那道题，f(n) = f(n-1) + f(n-2)
递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。
我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。
当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。

```c
// 我们实现假定 arr 数组已经初始化好的了。
int f(int n){
    if(n <= 1){
        return n;
    }
    //先判断有没计算过
    if(arr[n] != -1){
        //计算过，直接返回
        return arr[n];
    }else{
        // 没有计算过，递归计算,并且把结果保存到 arr数组里
        arr[n] = f(n-1) + f(n-1);
        reutrn arr[n];
    }
}
```

## 动态规划（Dynamic Programming）

即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。

「动态规划」中包含三个重要的概念：

【最优子结构】
【边界】
【状态转移公式】

在「 爬台阶问题 」中

f(10) = f(9) + f(8) 是【最优子结构】
f(1) 与 f(2) 是【边界】
f(n) = f(n-1) + f(n-2) 【状态转移公式】

最优子结构：如果问题的最优解所包含的子问题的解也是最优的，局部最优解能决定全局最优解，称之为最优子结构。

「 爬台阶问题 」 只是动态规划中相对简单的问题，因为它只有一个变化维度，如果涉及多个维度的话，那么问题就变得复杂多了。
难点就在于找出 「动态规划」中的这三个概念。
比如「 国王和金矿问题 」。

有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

![](https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e0c8a2a?imageView2/0/w/1280/h/960/ignore-error/1)


