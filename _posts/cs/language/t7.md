## 从栈实例化 和 从堆实例化(new,malloc) 的区别
栈上的内存一旦返回就必须清除，因为栈的原理就是每个调用在上一层调用的基础上再分配一段内存，返回的时候最终栈指针必须回到调用前的位置（有可能是调用方清理，也可能是被调用方清理，但总之都必须清理），这样栈上对象的生命周期不能超过调用开始到返回的区间，但许多数据结构都是需要超出这个范围的生命周期的，这时候必须将分配和释放拆分成两个和函数调用层次独立的过程，这就是堆空间的作用。


## new 和 malloc 内部的实现方式有什么区别？
> new: 为给定类型的变量在**运行时**分配**堆**内的内存，返回所分配的空间**地址**

new 的功能是在堆区新建一个**对象**，并返回该对象的**指针**。
所谓的【新建对象】的意思就是，将调用该类的**构造函数**，因为如果不构造的话，就不能称之为一个对象。
而 malloc 只是机械的分配一块内存，如果用 malloc 在堆区创建一个对象的话，是不会调用构造函数的。
严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。
同样的，用 **delete** 去释放一个堆区的对象，会调用该对象的**析构函数~**。
用 **free** 去释放一个堆区的对象，不会调用该对象的析构函数。

new/delete成对使用:
new负责在堆上创建对象。其中包括两个步骤：1）使用malloc分配内存 2）在分配的内存上创建对象，调用对象的构造函数；
delete负责销毁堆上的对象：1）调用对象的析构函数 2）free掉已分配内存。



