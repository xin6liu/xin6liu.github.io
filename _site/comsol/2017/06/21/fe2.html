<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

<head>
  <meta charset="utf-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      docker &middot; LiuXin
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/simple/poole.css">
  <link rel="stylesheet" href="/assets/css/simple/lanyon.css">
</head>



  <body>

    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">LiuXin</a>
            <small>COMSOL专题</small>
          </h3>
        </div>
      </div>
      <div class="container content">


<!-- 正文 -->
<div class="post">
  <h1 class="post-title">docker</h1>
  <span class="post-date">21 Jun 2017 </span>
  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});</script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <p>docker就像往集装箱里装货物的<strong>码头工人</strong>那样，它把<strong>应用</strong>打包成具有某种标准规格的<strong>集装箱</strong>，用计算机领域的语言来说，这种按照一定规格封装的集装箱叫<strong>「镜像」</strong>。其实就是<strong>将你原来的代码添加点额外的内容，格式之类的，生产出来的一个符合某种标准的东西。</strong></p>

<p>镜像：原画像复制品。
在docker中镜像是指，把你的应用按照一定的格式封装（其实就是执行一些符合特定规的命令行）成一种具有某种标准规格的东西（就像集装箱把你的货物封装起来类似）。形象的说，就是把你的应用按照一定的格式抽象的画了个画像。</p>

<p>在docker中，镜像是无法直接运行的，这并不是技术上的原因，而是出于工程设计上的考虑。因为一般来说，一个软件的<strong>某个具体版本</strong>只会打包成一个镜像。如果镜像可以配置，运行的话，在使用过程中很可能会对镜像造成破坏。</p>

<p>那怎么样避免镜像损坏的问题呢？就是再加一层，相当于分身术，只要本尊没问题，分身怎么扑街都不会真正的跪掉。多加的这一层分身，就叫<strong>容器（container）</strong>，这个名字也挺形象，它就像个盒子一样，你的应用在里面运行，而且多了一层安全机制。你想使用服务或把你的应用跑起来的话，只需要<strong>使用镜像新创建一个容器</strong>就可以了（也是一条命令搞定），而镜像还放在那里不动，没办法，金贵嘛。</p>

<p><strong>重点：</strong>docker究竟做了什么？
docker在部署过程中，将<strong>安装，配置等重复的部分</strong>，由docker<strong>自动化</strong>完成。只需要在<strong>第一次部署</strong>时，<strong>构建完可用的docker镜像</strong>（装好集装箱），在以后使用中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。所需要的仅仅是安装了docker的服务器，一个Dockerfile文件，以及比较流畅的网络而已。真可谓『一次构建，到处部署』。</p>

<ul>
  <li>需要python3环境？直接 from python:3.x 搞定。</li>
  <li>需要迁移服务器？ 直接把应用连带Dockerfile，备份数据拷贝到新服务器上，几条命令又搞定</li>
  <li>需要作为服务给别人使用？Dockerfile即是最清晰的部署文档，维护一个官方镜像即可，谁需要就直接拉下来几条命令部署上就行了。</li>
</ul>

<p>到这里你可能已经发现了，docker镜像成为了一种像集装箱那样的标准货件。它不像传统的软件交付方式那样，只把代码以及说明文档之类的给你就完了，而是直接给你一个标准docker货件，它可能是Dockerfile，或者直接就是镜像，这个标准件不仅包括了代码本身，还包括了代码运行的OS等各种整体环境。</p>

<p>于是，谁想用我的服务，直接拉取镜像，实例化一个容器就可以了，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p>

</div>

<!-- 相关 -->
<div class="related">
  <h1>CATEGORY</h1>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/ai/2018/03/18/ai.html">
            机器学习
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/comsol/2017/06/23/fe4.html">
            example2—possion
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/comsol/2017/06/22/fe3.html">
            example
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/comsol/2017/06/20/fe1.html">
            Solving the Poisson equation
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/comsol/2017/06/19/fe0.html">
            Docker + FEniCS
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/comsol/2017/06/12/tf3.html">
            Two-Fluid Model — two-fluid model
          </a>
        </h3>
      </li>
    
  </ul>
</div>


</div>
    </div>

  </body>
</html>
